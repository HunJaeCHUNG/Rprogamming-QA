---
# title: "Vector filtration"
author: "Issac Lee"
date: "`r Sys.Date()`"
output: markdowntemplates::skeleton
---
## Vector filtration in R

이제까지 우리는 R에서 벡터를 정의하는 방법에 대하여 알아봤다. 이번 포스팅에서는 이미 정의된 벡터를 가지고 노는? 방법에 대하여 알아보도록 하겠다.

x라는 이름의 벡터를 다음과 같이 미리 정의해 놓았다고 하자.
```{r}
x <- c(1:10)
x
```
정의된 벡터 x의 특정 원소를 선택하고 싶은 경우, **[ ]** 대괄호 연산자를 사용할 수 있는데 예를 들어 x 벡터의 두번째 원소를 선택하고 싶은 경우에는 다음과 같이 입력하면 된다.
```{r}
x[2]
```
따라서, 이러한 대괄호 연산자를 이용하여 새로운 벡터를 정의할 수 도 있다. 다음의 코드는 벡터 x의 첫번째 세번째 원소만을 원소로 가지는 새로운 벡터 y를 정의하는 코드이다.
```{r}
y <- x[c(1,3)]
y
```
위의 코드에서 느껴?지는 것처럼 대괄호 연산자, **[ ]**,는 필터 역할을 한다고 생각하면 좋겠다. 대괄호 안의 **c()**가 잘 작동하는 것처럼, 이제까지 우리가 배운 많은 연산자들 역시도 똑같이 작용한다! 몇가지 예를 보도록 하자.

첫번째로 벡터 x의 첫번째부터 다섯번째 원소까지를 선택하여 새로운 벡터를 만들고 싶은 경우 다음과 같은 코드를 사용하여 정의 할 수 있다.
```{r}
y <- x[1:5]
y
```
두번째로, 만약 우리가 벡터 x의 세번째 원소만을 가지고 길이가 4인 벡터를 만들고 싶다면, 전 포스팅에서 공부한 **rep()** 명령어를 사용하면 된다.
```{r}
y <- x[rep(3,4)]
y
```
세번째로, R 연산이 가지는 특성을 잘 활용하면 벡터 x의 짝수번째 원소들만을 가지는 새로운 벡터 y를 다음과 같이 정의 할 수 있다.
```{r}
y <- x[1:5*2]
y
```
위의 코드를 이해하기 위해서는 먼저 대괄호 안의 연산을 이해해야 한다.
```{r}
1:5 * 2
```
보시다시피 R에서는 벡터에 상수를 곱할 경우, 자동으로 아래와 같은 벡터의 스칼라 곱으로 이해하여 처리하는 것을 알 수있다. 
$$
2a=2\times\left(\begin{array}{c}
1\\
2\\
3\\
4\\
5
\end{array}\right)=\left(\begin{array}{c}
2\\
4\\
6\\
8\\
10
\end{array}\right)
$$
그러므로 위에서 사용된 코드, **x[1:5*2]**,는 사실상 다음과 같이 벡터 y를 정의하는 코드와 동일한 것이다.
```{r}
y <- x[c(2,4,6,8,10)]
y
```
그렇다면 벡터 x의 홀수번 째 원소만을 뽑아서 벡터를 정의하려면 어떻게 해야할까? 힌트: 1만 빼면 된다.

다음 시간에는 필터링에 대하여 좀 더 알아보도록 하자.

```{r bib, include=FALSE}
# KEEP THIS AT THE END OF THE DOCUMENT TO GENERATE A LOCAL bib FILE FOR PKGS USED
knitr::write_bib(sub("^package:", "", grep("package", search(), value=TRUE)), file='skeleton.bib')
```